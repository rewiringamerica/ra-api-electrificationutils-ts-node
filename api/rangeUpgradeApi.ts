/**
 * smallmodelsapi
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { EnergyTradeoff } from '../model/energyTradeoff';
import { HTTPValidationError } from '../model/hTTPValidationError';
import { RangeFuelType } from '../model/rangeFuelType';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RangeUpgradeApiApiKeys {
}

export class RangeUpgradeApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RangeUpgradeApiApiKeys, value: string) {
        (this.authentications as any)[RangeUpgradeApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Analyze the potential energy usage effects of a range upgrade.  We assume that the caller is contemplating replacing a natural gas or propane-burning range with an electric one. Based on the fuel their current range uses and the number of occupants in their household, we estimate how the use of electricity, natural gas, and propane will be likely to change under three different scenarios.  The scenarios are low, medium, and high use, which correspond to using a range 80% as much as a typical household, exactly as much as a typical household, and 120% as much as a typical household.  Parameters ---------- current_fuel     The currently used fuel. occupants     the number of occupants in the household.  Returns -------     Changes in energy use across a number of fuels.
     * @summary Range Upgrade
     * @param currentFuel The fuel used by the current range.
     * @param occupants The number of occupants in the household.
     */
    public async rangeUpgrade (currentFuel: RangeFuelType, occupants: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<EnergyTradeoff>;  }> {
        const localVarPath = this.basePath + '/api/v1/range_upgrade/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'currentFuel' is not null or undefined
        if (currentFuel === null || currentFuel === undefined) {
            throw new Error('Required parameter currentFuel was null or undefined when calling rangeUpgrade.');
        }

        // verify required parameter 'occupants' is not null or undefined
        if (occupants === null || occupants === undefined) {
            throw new Error('Required parameter occupants was null or undefined when calling rangeUpgrade.');
        }

        if (currentFuel !== undefined) {
            localVarQueryParameters['current_fuel'] = ObjectSerializer.serialize(currentFuel, "RangeFuelType");
        }

        if (occupants !== undefined) {
            localVarQueryParameters['occupants'] = ObjectSerializer.serialize(occupants, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<EnergyTradeoff>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<EnergyTradeoff>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
